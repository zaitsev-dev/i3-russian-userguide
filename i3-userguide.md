# Руководство пользователя i3

Автор: Майкл Штапельберг, michael@i3wm.org

Перевод: Алексей Литовский, a.leetovskiy@gmail.com

[TOC]

Эта документация содержит всю информацию, которая пригодится для использования и конфигурации оконного менеджера i3. Если по прочтении у Вас остались вопросы, пожалуйста, загляните сначала на https://www.reddit.com/r/i3wm/, затем свяжитесь с нами по IRC (предпочтительно) или опубликуйте свой вопрос в списке почтовой рассылки.

## 1. Стандартные сочетания клавиш

Специально для людей, которые не любят много читать, есть небольшая шпаргалка со стандартными сочетаниями клавиш.

**Сочетания с использованием клавиши $mod (Alt или Super):**

![Сочетания с использованием клавиши $mod (Alt или Super)](https://i3wm.org/docs/keyboard-layer1.png)

**Сочетания с использованием клавиш Shift+$mod:**

![Сочетания с использованием клавиш Shift+$mod](https://i3wm.org/docs/keyboard-layer2.png)

Красные клавиши это модификаторы, которые нужно зажать, голубые – домашний ряд.

Обратите внимание, если запуск i3 сопровождается отсутствием конфигурационного файла, *i3-config-wizard* предложит создать его. Позиции клавиш в этом случае будут совпадать с теми, что изображены на шпаргалке, независимо от раскладки клавиатуры. Если Вы хотите использовать файл конфигурации, где буквенные клавиши совпадают с тем, что вы видите выше, просто отклоните предложение i3-config-wizard и основывайте свою конфигурацию на файле **/etc/i3/config** (прим. переводчика: имеется ввиду, что во втором случае Вы хотите использовать именно буквенные сочетания вместо позиций клавиш).

## 2. Использование i3

В этом руководстве ключевое слово **$mod** ссылается на сконфигурированный модификатор клавиш. По умолчанию это клавиша Alt (**Mod 1**) или Windows (**Mod 4**), которая является популярной альтернативой, предотвращающей конфликты между сочетаниями клавиш, используемыми приложениями.

### 2.1. Запуск терминала и переключение между окнами

Одна из самых базовых операций это запуск терминала. По умолчанию для этого используется сочетание клавиш **$mod+Enter** или Alt+Enter (**Mod1+Enter**) в стандартной конфигурации. По нажатию **$mod+Enter** откроется новый терминал. Он займет все доступное пространство на экране.

![Окно терминала](https://i3wm.org/docs/single_terminal.png)

Теперь, если открыть еще один терминал, i3 поместит его после существующего, разделив экран пополам. В зависимости от Вашего монитора, созданное окно появится рядом с существующим окном (на широких экранах) или под ним.

<img src="https://i3wm.org/docs/two_terminals.png" alt="Два терминала рядом"  />

Чтобы переместить фокус между двумя терминалами можно использовать клавиши направления идентичные редактору **Vi**. Однако, в i3 используется домашний ряд, а в **Vi** эти клавиши смещены влево на одну для совместимости с большинством клавиатурных раскладок. Следовательно, **$mod+j** – направление влево, **$mod+k** – направление вниз, **$mod+l** – вверх, **$mod+;** – вправо. То есть, чтобы переключиться между терминалами нужно использовать **$mod+k** или **$mod+l**. И, конечно же, Вы можете использовать клавиши стрелок. 
Сейчас рабочая область разделена (она содержит два окна терминала) в определенном направлении (горизонтальное по умолчанию). Каждое окно можно разделить еще раз по горизонтали или вертикали прямо как рабочую область, которую мы до этого разделили. Термин "окно" используется для контейнера, который на самом деле содержит окно X11 такие, как терминал или браузер, а "split-контейнер" (разделенный контейнер, далее – сплит-контейнер) для контейнеров, которые состоят из одного или нескольких окон.
Чтобы разделить окно по вертикали нажмите **$mod+v**, прежде чем создать новое окно.

### 2.2. Изменение раскладки контейнера

Сплит-контейнер может иметь одну из следующих раскладок:

|                        splith/splitv                         |                           stacking                           |                            tabbed                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| Окна масштабируются по принципу, чтобы каждое из них забирало равное пространство контейнера. ***splith*** распределяет окна по горизонтали (они находятся рядом друг с другом), а ***splitv*** распределяет их по вертикали (окна находятся друг над другом). | В контейнере отображается только то окно, которое в фокусе. Также, сверху контейнера появляется список окон. | Аналогичен ***stacking***, только список окон отображается горизонтально, как вкладки в браузере. |

Чтобы переключаться между режимами раскладки используйте **$mod+e** для ***splith/splitv*** (переключаются между друг другом), **$mod+s** для ***stacking*** и **$mod+w** для ***tabbed***.

![Режимы раскладки контейнера](https://i3wm.org/docs/modes.png)

### 2.3. Переключение полноэкранного режима окна

Для того, чтобы включить или выключить полноэкранный режим окна используйте **$mod+f**.

Также, в i3, существует глобальный полноэкранный режим, который охватывает все доступные выводы. Переключается командой `fullscreen toggle global`.

### 2.4. Запуск других приложений

Вместо того, чтобы запускать приложения из терминала можно использовать удобный лаунчер ***dmenu***, который по умолчанию открывается сочетанием клавиш **$mod+d**. Просто наберите имя приложения (или его часть), которое хотите запустить. Для работы требуется, чтобы приложение находилось в переменной **$PATH**.

Также, для приложений, которые Вы запускаете часто, можно напрямую задать сочетания клавиш. Подробнее в разделе [Настройка](#configuring).

### 2.5. Закрытие окон

Если приложение не предусматривает механизм завершения (большинство из них предусматривает меню, клавишу escape или горячие клавиши типа **Control-w** для закрытия), можно использовать **$mod+Shift+q**, чтобы "убить" окно. Для приложений, которые поддерживают протокол WM_DELETE, это действие правильно закроет окно (сохранит любые изменения и т.п.). Если же приложение не поддерживает WM_DELETE, то X-сервер просто "убьет" окно, а поведение будет зависеть от определенного приложения.

### 2.6. Использование рабочих пространств

Рабочие пространства (workspaces) это простой способ сгруппировать набор окон. По умолчанию Вы находитесь на первом рабочем пространстве, об этом сообщает индикатор на панели, что находится внизу слева. Чтобы переключиться на другое рабочее пространство нажмите **$mod+num**, где **num** это номер рабочего пространства, которое Вы хотите использовать. Если его не существует, оно будет создано.

Простое применение для этого – переместить браузер на одно рабочее пространство, приложения для общения в сети в другое, а те, с которыми Вы работаете, в третье. Конечно же, Вы не обязаны использовать этот подход.

Если у Вас несколько мониторов, рабочее пространство будет создано для каждого из них во время запуска. Если создать новое рабочее пространство, оно будет привязано к тому экрану, на котором было создано. При переключении к рабочему пространству из другого монитора i3 установит фокус на этот экран.

### 2.7. Перемещение окон между рабочими пространствами

Чтобы переместить окно в другое рабочего пространство просто нажмите **$mod+Shift+num**, где **num** это номер нужного пространства. Также как при переключении, нужное пространство будет создано, если его еще не существует.

### 2.8. Изменение размера

Самый простой способ изменить размер контейнера это использовать мышь: зажмите мышь на границе окна и тяните ее до нужного размера.

Также можно использовать [режим привязки](#binding_modes) клавиш, чтобы менять размеры окна используя клавиатуру. Для примера гляньте на [стандартный конфигурационный файл](https://github.com/i3/i3/blob/next/etc/config.keycodes) предоставленный i3.



### 2.9. Перезапуск i3

Чтобы перезапустить i3 нажмите **$mod+Shift+r**. Пригодится, если произошла какая-то ошибка или нужно обновиться до новой версии оконного менеджера.

### 2.10. Выход из i3

Чтобы выйти из i3 не завершая работу X-сервера можно использовать **$mod+Shift+e**. По умолчанию появится диалоговое окно, которое попросит подтвердить операцию.

### 2.11. Плавающий режим

Плавающий (floating) режим является обратным тайловому. Положение и размеры окна регулируются пользователем вручную, а не автоматическим режимом i3. Использование этого режима нарушает парадигму тайлинга, но может быть полезно для некоторых случаев, когда появляются диалоговые окна (например, "Сохранить как") или окна панели инструментов (GIMP или подобные). Такие окна обычно оставляют подсказку для оконных менеджеров и открываются в плавающем режиме по умолчанию.

Переключить плавающий режим для окна можно с помощью сочетаний **$mod+Shift+Space**. Перетаскивая заголовок окна с помощью мыши можно перемещать окно по рабочему пространству. Чтобы изменить размер нужно зажать и тянуть рамку окна. Также это можно делать с помощью [floating_modifier](#floating_modifier) (модификатора плавающих окон). Еще один способ это зажать и тянуть ПКМ в заголовке окна.

Об изменении размера плавающих окон с клавиатуры см. режим привязки изменения размера, предусмотренный [конфигурацией i3 по умолчанию](https://github.com/i3/i3/blob/next/etc/config.keycodes).

Плавающие окна всегда находятся поверх тайлинговых.

## 3. Дерево

i3 собирает всю информацию из вывода X11. Рабочие пространства и расположение окон находятся внутри некоего дерева. Корневым узлом является корневое окно X11, за ним следуют выводы X11, затем области стыковки и контейнер содержимого, рабочие области и, наконец, сами окна. 

В предыдущих версиях i3 мы имели несколько списков (выводов, рабочих пространств) и таблицу для каждой рабочей области. Этот подход оказался сложным для использования, понимания и реализации.

### 3.1. Дерево состоит из контейнеров

Кирпичики нашего дерева это контейнеры. Контейнер может содержать окно. Имеется в виду окно X11, которое можно видеть и использовать (например, браузер). Помимо этого, контейнер может содержать другие контейнеры. Простой пример – рабочее пространство: когда i3 запущен с одним монитором, одним рабочим пространством и открыто два терминальных окна, дерево будет выглядеть так:

![Дерево окон](https://i3wm.org/docs/tree-layout2.png)

![Два терминальных окна в одном контейнере](https://i3wm.org/docs/tree-shot4.png)

### 3.2. Ориентация и сплит-контейнеры

При использовании дерева в качестве структуры данных вполне естественно использовать так называемые *сплит-контейнеры* (разделенные контейнеры) для построения раскладки. В i3 каждый *контейнер* имеет свою ориентацию (горизонтальная, вертикальная или неопределенная) и зависит она от раскладки этого контейнера (вертикальная для *splitv* и *stacking*, горизонтальная для *splith* и *tabbed*). В нашем примере с рабочим пространством раскладкой по умолчанию для контейнера является *splith* (большинство мониторов в настоящее время широкоэкранные). Если изменить раскладку на *splitv* (**$mod+v** по умолчанию) и открыть два терминала, то i3 расположит их таким образом:

![Вертикальная ориентация](https://i3wm.org/docs/tree-shot2.png)

С версии 4 i3 имеет интересную возможность – разделять все что угодно: представим, что у нас есть два терминала в рабочем пространстве (в раскладке *splith*, что является горизонтальной ориентацией), фокус окна стоит на правом терминале. Теперь давайте откроем еще один терминал ниже существующего. Если бы мы просто открыли новое окно терминала, то оно отобразилось бы справа благодаря splith-раскладке. Вместо этого нажмите **$mod+v**, чтобы разделить контейнер следуя splitv-раскладке (чтобы открыть горизонтальный сплит-контейнер используйте **$mod+h**). Теперь можно открыть терминал и он появится ниже существующего:

![Вертикальный сплит-контейнер](https://i3wm.org/docs/tree-shot1.png)

![Дерево окон](https://i3wm.org/docs/tree-layout1.png)

Вы, наверное, уже догадались, что нет ограничения в том, насколько глубокой может быть иерархия сплитов.

### 3.3. Фокусировка на родителе

Давайте оставим вышеуказанный пример. У нас есть терминал слева и два вертикально разделенных терминала справа, фокус на нижнем правом. При открытии нового окна оно откроется ниже текущего.

Как открыть терминальное окно справа от существующего? Для этого нужно переместить фокус на родительский контейнер. В конфигурации по умолчанию для этого используется **$mod+a**, чтобы переместиться на один контейнер выше по дереву (эту операцию можно повторить несколько раз, пока Вы не попадете на контейнер рабочего пространства). В нашем случае вы переместите фокус на *вертикальный контейнер*, который находится внутри горизонтально ориентированной рабочей области. Теперь новые окна будут открываться справа от *вертикального сплит-контейнера*:

![shot3](https://i3wm.org/docs/tree-shot3.png)

### 3.4. Неявные контейнеры

В некоторых случаях i3 необходимо неявно создать контейнер для выполнения команды пользователя.

Например: вы запускаете i3 с одним монитором и одной рабочей областью, на которой открываете 3 терминальных окна. Все эти окна напрямую прикрепляются к одному узлу внутри дерева раскладки i3 – узлу рабочей области. По умолчанию узел рабочей области ориентирован *горизонтально*.

Теперь вы перемещаете один из этих терминалов вниз (**$mod+Shift+k** по умолчанию). Ориентация узла рабочей области изменится на *вертикальную*. Окно терминала, которое вы переместили вниз, прикреплено непосредственно к рабочей области и появляется в нижней части экрана. Для размещения двух других окон терминала был создан новый (горизонтальный) контейнер. Вы заметите это при переходе в режим вкладок (например). В результате у вас появится одна вкладка с изображением разделенного контейнера (например, "H[urxvt firefox]"), а другая - терминальное окно, которое вы переместили вниз.

## 4. <span id="configuring">Настройка i3</span>

Здесь начинается настоящее веселье! У каждого имеется свое представление идеального рабочего окружения, поэтому мы не можем сделать разумные настройки по умолчанию для всех пользователей.

Несмотря на то, что i3 не использует язык программирования для конфигурации, он остается достаточно гибким для того, что вы обычно хотите от оконного менеджера.

Например, вы можете настроить: сочетания клавиш для отдельных окон, горячие клавиши для запуска определенных приложений на определенном рабочем пространстве, автоматический запуск приложений, внешний вид i3, установить ваши собственные сочетания клавиш для каких-нибудь полезных вещей.

Чтобы изменить конфигурацию i3 скопируйте файл из `/etc/i3/config` в `~/.i3/config` (или в `~/.config/i3/config`, если вам нравится схема директорий XDG) и отредактируйте его любым текстовым редактором.

При первом запуске (и любом другом, если у вас нет конфигурационного файла) i3 предложит создать конфигурационный файл. В мастере настроек можно выбрать между использованием Alt (**Mod1**) или Windows (**Mod4**) в качестве модификатора. Кроме того, созданный конфигурационный файл будет использовать ключевые символы, основываясь на вашей текущей раскладке клавиатуры. Чтобы запустить мастер настройки используйте команду `i3-config-wizard`. Обратите внимание, что у вас не должно быть файла `~/.i3/config`, иначе мастер настройки просто закроется.

i3, начиная с версии 4.0, использует новый формат конфигурации. i3 попытается автоматически определить версию формата конфигурационного файла, основываясь на нескольких различных ключевых словах, но если вы хотите убедиться, что ваш конфигурационный файл читается в новом формате, включите следующую строку в ваш конфигурационный файл:

`# i3 config file (v4)`

### 4.1. Комментарии.

Рекомендуется использовать комментарии в конфигурационном файле, чтобы правильно задокументировать ваши настройки для последующего использования. Комментарии начинаются с символа **#** и могут быть использованы только в начале строки:

`# Это строка с комментарием`

### 4.2 <span id="fonts">Шрифты</span>

i3 поддерживает как основные шрифты X, так и шрифты FreeType (с помощью Pango) для отображения оконных заголовков.

Для генерации описания шрифта X можно использовать *xfontsel(1)*. Чтобы увидеть специальные символы (Unicode), вам нужно использовать шрифт, который поддерживает кодировку ISO-10646.

Описание шрифтов FreeType состоит из семейства шрифтов (font family), стиля (style), толщины (вес, weight), варианта (variant), растяжки (stretch) и размера (size). Шрифты FreeType поддерживают отображение справа налево и чаще всего содержат больше Unicode-символов, нежели основные шрифты X.

Если i3 не может открыть заданный в конфигурации шрифт, то он выведет ошибку в log-файл и будет использовать тот, который работает.

**Синтаксис:**

```
font <описание X-шрифта>
font pango:<список семейств> [<опции стиля>] <размер>
```

**Примеры:**

```
font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1
font pango:DejaVu Sans Mono 10
font pango:DejaVu Sans Mono, Terminus Bold Semi-Condensed 11
font pango:Terminus 11px
```

### 4.3. Клавиатурные бинды

Клавиатурные бинды (привязки клавиш) говорят i3, что нужно запустить команду (см. ниже) при нажатии определенной клавиши. i3 позволяет вам забиндить (привязать) как на конкретный keycode (клавиатурный код), так и на keysym (определенный символ). Вы также можете смешивать эти два подхода, но i3 не защитит вас от случая, когда бинды пересекаются.

* Keysym (key symbol, ключ символа) – описание для конкретного символа, такого как "a" или "b", но также могут быть и менее очевидные описания, например, "underscore" вместо "_". Это то, что вы используете в Xmodmap для переноса ключей. Чтобы получить список текущих ключей и их биндов используйте `xmodmap -pke`. Чтобы интерактивно узнать предназначение клавиши используйте `xev`.
* Keycodes не требует назначения символов (удобно для горячих клавиш от поставщика на некоторых ноутбуках) и их предназначение не изменится когда вы смените раскладку клавиатуры на другую (при использовании `xmodmap`).

Рекомендация от автора документации: если вы часто меняете раскладку клавиатуры, но хотите оставить бинды в том же физическом расположении клавиатуры, используйте keycodes. Если вы не меняете раскладку и хотите иметь чистый и простой конфигурационный файл, то используйте keysyms.

Некоторые утилиты (такие как *import* или *xdotool*) могут не запускаться при нажатии клавиш, потому что клавиатура/курсор все еще удерживаются. Для подобных ситуаций может быть полезен флаг `--release`, который выполнит команду после того, как клавиши будут отпущены.

**Синтаксис:**

```
bindsym [--release] [<Группа>+][<модификаторы>+]<keysym> команда
bindcode [--release] [<Группа>+][<модификаторы>+]<keycode> команда
```

**Примеры:**

```
# Переключение полноэкранного режима окна
bindsym $mod+f fullscreen toggle

# Перезапуск i3
bindsym $mod+Shift+r restart

# Специфичные горячие клавиши для ноутбука
bindcode 214 exec --no-startup-id /home/michael/toggle_beamer.sh

# Симуляция ctrl+v при нажатии $mod+x
bindsym --release $mod+x exec --no-startup-id xdotool key --clearmodifiers ctrl+v

# Сделать скриншот области экрана при нажатии $mod+x
bindsym --release $mod+x exec --no-startup-id import /tmp/latest-screenshot.png
```

**Доступные модификаторы**

От Mod1 до Mod5, Shift, Control – стандартные модификаторы, см. *xmodmap(1)*.

**Group1, Group2, Group3, Group4**

При использовании нескольких раскладок клавиатуры (например `setxkbmap -layout us,ru`) можно указать в какой группе XKB должна быть активна раскладка клавиатуры. По умолчанию бинды клавиш переведены в Group1 и активны во всех группах. Если вы хотите переопределить бинды клавиш в одной из ваших раскладок, установите соответствующую группу. Для обратной совместимости используйте "Mode_switch" в качестве алиаса для Group2.

### 4.4. Бинды для мыши

Бинды для мыши сообщают i3 о том, что нужно выполнить определенную команду, когда нажата заданная кнопка мыши в рамках контейнера, где вы кликнули (см. [command_criteria] TODO: добавить ссылку на раздел). Вы можете настроить бинды для мыши таким же образом, как и для клавиатурных клавиш.

**Синтаксис:**

```
bindsym [--release] [--border] [--whole-window] [--exclude-titlebar] [<модификаторы>+]button<n> command
```

По умолчанию бинды будут работать тогда, когда вы кликаете по заголовку окна. Если установлен флаг `--release`, то команда будет запущена после того, как кнопка мыши будет отпущена.

Если установлен флаг `--whole-window`, бинд выполнится в любой части окна, за исключением границы. Чтобы изменить поведение с границей окна установите флаг `--border`.

Если установлен флаг `--exclude-titlebar`, то строка заголовка не будет учитываться.

**Примеры:**

```
# Ср. кнопка мыши над заголовком "убивает" окно
bindsym --release button2 kill

# Ср. кнопка мыши и модификатор над любой частью окна "убивает" окно
bindsym --whole-window $mod+button2 kill

# Пр. кнопка мыши переключает переключает плавающий режим
bindsym button3 floating toggle
bindsym $mod+button3 floating toggle

# Боковые клавиши перемещают окна
bindsym button9 move left
bindsym button8 move right
```

### 4.5. <span id="binding_modes">Режимы привязки</span>

Используя разные режимы привязки вы можете установить несколько наборов биндов. При переходе в другой режим привязки все бинды из текущего режима освобождаются, и только бинды, определенные в новом режиме, будут действительны до тех пор, пока вы остаетесь в нем. Единственный заранее определенный режим привязки это *стандартный* (default). С ним изначально i3 начинает работу и ему же принадлежат все бинды, которые не определены в конкретный режим.

Работа с режимами привязки складывается из двух вещей: определение режима привязки и переключение к нему. Для этих задач есть одна конфигурационная директива и одна команда. Оба из них называются *режимами*. Директива используется для определения биндов, принадлежащих конкретному режиму привязки, при этом команда переключится в заданный режим.

Рекомендуется использовать режимы привязки в паре с [переменными](#variables), чтобы облегчить поддержку конфигурации. Ниже есть пример того как использовать режим привязки.

Обратите внимание, что рекомендуется назначить бинды для возврата в режим по умолчанию.

Для режимов привязки можно использовать [[pango_markup]()(TODO: указать ссылку)], но необходимо будет включить его, передав флаг `--pango_markup` в определение режима.

**Синтаксис:**

```
# директива конфигурации
mode [--pango_markup] <name>

# команда
mode <name>
```



**Пример:**

```
# Нажмите $mod+o, а затем f, t, Escape или Return, чтобы 
# запустить Firefox,Thunderbid или вернуться в режим по умолчанию.
set $mode_launcher Launch: [f]irefox [t]hunderbird
bindsym $mod+o mode "$mode_launcher"

mode "$mode_launcher" {
    bindsym f exec firefox
    bindsym t exec thunderbird

    bindsym Escape mode "default"
    bindsym Return mode "default"
}
```

### 4.6. <span id="floating_modifier">Floating-модификатор</span>

Для перемещения плавающих окон можно тянуть их мышью за заголовок или настроить так называемый floating-модификатор, который вы можете затем нажать и щелкнуть в любом месте самого окна, чтобы переместить его. Наиболее распространенной практикой является использование той же клавиши, которой вы используете для управления окнами (Mod1, например). Затем вы можете нажать кнопку Mod1, щелкнуть по окну левой кнопкой мыши и перетащить его в нужное положение.

Удерживая floating-модификатор, вы можете изменить размер плавающего окна, нажимая на него правой кнопкой мыши и перемещая курсор, удерживая клавишу. Если при этом зажать клавишу Shift, то изменение размера будет пропорциональным.

**Синтаксис:**
```
floating_modifier <модификатор>
```

**Пример:**
```
floating_modifier Mod1
```

### 4.7. Ограничение размеров плавающего окна

Можно указать максимальные и минимальные размеры для плавающих окон. Если из размерностей `floating_maximum_size` указан в значении "-1", то эта размерность будет неограниченной по отношению к ее максимальному значению. Если же размерность не определена или указана как "0", то i3 будет использовать значение по умолчанию для ограничения максимального размера. Это же относится и к параметру `floating_minimum_size`.

**Синтаксис:**
```
floating_minimum_size <ширина> x <высота>
floating_maximum_size <ширина> x <высота>
```

**Пример:**
```
floating_minimum_size 75 x 50
floating_maximum_size -1 x -1
```

### 4.8. Ориентация для новых рабочих областей

Новые рабочие области по умолчанию получают разумную ориентацию: широкоэкранные мониторы (когда ширина больше высоты) получают горизонтальную ориентацию, поворачивающиеся дисплеи (когда высота больше ширины) – вертикальную.

С помощью директивы `default_orientation` можно изменить это поведение.

**Синтаксис:**
```
default_orientation horizontal|vertical|auto
```

**Пример:**
```
default_orientation vertical
```

### 4.9. Режим раскладки для новых контейнеров

Эта опция определяет в каком режиме будут запускаться новые контейнеры на уровне рабочей области.

**Синтаксис**:
```
workspace_layout default|stacking|tabbed
```

**Пример**:
```
workspace_layout tabbed
```

### 4.10. Выравнивание заголовков окон

Эта опция определяет выравнивание текста в заголовке окна. По умолчанию установлен *left*.

**Синтаксис:**
```
title_align left|center|right
```

### 4.11. Стилизация границы для новых окон

Эта опция определяет стиль для границ новых окон. Значение по умолчанию – *normal*. Обратите внимание, `default_floating_border` применяется только к окнам, которые изначально запущены в режиме *floating* (например, диалоговые окна) и не применяется к тем, которые стали плавающими позже.

Установка стиля границы в режим *pixel* исключает строки заголовков. Стиль *normal* позволяет регулировать ширину границы, сохраняя при этом строку заголовка.

**Синтаксис:**
```
default_border normal|none|pixel
default_border normal|pixel <px>
default_floating_border normal|none|pixel
default_floating_border normal|pixel <px>
```

Обратите внимание, что *new_window* и *new_float* устарели в пользу вышеуказанных опций и будут удалены в будущем. Мы настоятельно рекомендуем использовать новые опции вместо них.

**Пример:**
```
default_border pixel
```

Опции "normal" и "pixel" поддерживают ширину границ в пикселях, хотя это не обязательно указывать.

**Пример:**
```
# Тоже самое, что default_border none
default_border pixel 0

# Граница в 3 пикселя шириной
default_border pixel 3
```

### 4.13. Произвольные команды для конкретных окон (for_window)

Используя директиву `for_window` можно позволить i3 выполнить любую команду при столкновении с определенным окном. Например, это можно использовать, чтобы установить окна в плавающий режим или изменить стиль его границ.

**Синтаксис:**

```
for_window <условие> <команда>
```

**Пример:**
```
# включить плавающий режим для всех окон XTerm
for_window [class="XTerm"] floating enable

# для всех окон urxvt использовать границы в 1 пиксель 
for_window [class="urxvt"] border pixel 1

# Не совсем полезный, но забавный пример:
# сделать окно плавающим, когда каталог меняется на ~/work
for_window [title="x200: ~/work"] floating enable
```

Действующие критерии (условия) и команды см. в разделе command_criteria (TODO: добавить ссылку на раздел 6). Выполняться могут только команды, а не директивы конфигурации, см. раздел list_of_commands (TODO: добавить ссылку).

### <span id="no_focus">4.14. Отключить фокусировку на новом окне</span>

Когда появляется новое окно, оно тут же попадет в фокус. Директива `no_focus` позволяет изменить это поведение и должно быть использовано в комбинации с command_criteria (TODO: добавить ссылку).

Обратите внимание, что это работает не во всех случаях, например, при передаче данных в запущенное приложение, потому что оно требует фокус. Чтобы настроить поведение для таких случаев, обратитесь к разделу [Фокус при активации окна](#focus_on_window_activation).

`no_focus` будет проигнорирован и в том случае, если открыто первое окно в рабочем пространстве. Это позволяет повысить удобство использования в сочетании с `workspace_layout`.

**Синтаксис:**

```
no_focus <условие>
```

**Пример:**
```
no_focus [window_role="pop-up"]
```

### <span id="variables">4.15. Переменные</span>

Как вы узнали в разделе о клавиатурных привязках, вам придется настроить множество биндов, включающих в себя клавиши-модификаторы. Если хочется сэкономить время при создании конфигурации и иметь потом возможность поменять используемый модификатор, то вам пригодятся переменные.

**Синтаксис:**

```
set $<имя> <значение>
```

**Пример:**
```
set $m Mod1
bindsym $m+Shift+r restart
```

Переменные заменяются в файле во время парсинга. Переменные разбираются не рекурсивно, поэтому невозможно определить переменную со значением, содержащим другую переменную. Это совершенно не доставляет никаких проблем, менять это поведение не планируется. Если же вы хотите более гибкую конфигурацию, то вы должны создать небольшой скрипт, который генерирует конфигурационный файл и запускается раньше, чем i3 (например, в файле*~/.xsession* ).

Смотрите [Ресурсы X](#xresources), чтобы узнать как создавать переменные на основе ресурсов, загруженных из базы данных xresources.

### 4.16. <span id="xresources">Ресурсы X</span>

[Переменные](#variables) также могут быть созданы с помощью значений, настроенных в базе данных ресурсов X. Например, это полезно, чтобы избежать настройки значений в конфигурации i3. Вместо этого, значения можно задать единожды, в базе данных ресурсов X, для достижения легко поддерживаемой, согласованной цветовой темы во многих X-приложениях. 

Указание ресурса приведет к тому, что он будет загружен из БД ресурсов и присвоит его значение указанной переменной. Это делается буквально, поэтому значение должно быть в формате, который использует i3. Также должно быть указано запасное значение на случай, если ресурс не сможет загрузиться из базы данных.

**Синтаксис:**
```
set_from_resource $<имя> <имя_ресурса> <запасное_значение>
```
**Пример:**
```
# Файл ~/.Xresources должен содержать подобную строку:
#     *color0: #121212
# и должен быть загружен должным образом, например, так:
#     xrdb ~/.Xresources
# Это значение подхватывается другими приложениями (например, эмулятором терминала URxvt) и может быть использовано в i3 подобным образом:
set_from_resource $black i3wm.color0 #000000
```

### 4.18. Автозапуск приложений в i3

Используя ключевое слово `exec`, отдельно от объявления бинда, вы можете задать команды, которые выполнятся во время начального запуска i3. Команды `exec` не будут запущены во время перезапуска i3, но если вам это нужно, используйте `exec_always`. Также, все эти команды будут выполняться по порядку.

Смотрите [command_chaining]()(TODO: добавить ссылку на раздел 6) для получения подробной информации об особом значении символов `;` (точка с запятой) и `,` (запятая). Они связывают вместе команды в i3, поэтому необходимо использовать кавычки (как показано в [exec_quoting]()(TODO: добавить ссылку на раздел 6.1)), если они используются в вашей команде.

**Синтаксис:**

```
exec [--no-startup-id] <команда>
exec_always [--no-startup-id] <команда>
```

**Примеры:**

```
exec chromium
exec_always ~/my_script.sh

# Запустить эмулятор терминала urxvt, о запуске которого пока неизвестно
exec --no-startup-id urxvt
```

Про флаг `--no-startup-id` рассказывается в [exec]()(TODO: добавить ссылку на раздел 6.1).

### 4.19. Автоматизация перемещения рабочих областей на конкретные экраны

Если вы используете несколько экранов, то может быть удобно разместить каждую рабочую область на отдельном экране. Кроме того, распределение рабочих областей на экраны будет влиять на то, какая область i3 будет использовать для нового экрана при его добавлении или запуске самого i3 (например, по умолчанию i3 использует 1 раб. область для первого экрана, 2 для второго и так далее).

**Синтаксис:**
```
workspace <рабочая_область> output <выход1> [выход2]…
```

*Выход* является именем RandR выхода, который прикреплен к вашему экрану. На ноутбуках могут быть такие имена как VGA1 и LVDS1. Посмотреть доступные выходы можно с помощью команды `xrandr --current`.

Если ваш X-сервер поддерживает RandR 1.5 или выше, i3 будет использовать объекты RandR-монитора вместо объектов вывода. Запустите `xrandr --listmonitors`, чтобы увидеть список. Обычно объекты монитора содержат только один вывод и их имена, объектов и вывода, совпадают. Но если это не так, в конфигурации i3 вы можете указать либо имя монитора, либо имя выхода. Например, внутри Dell UP2414Q используются два сканера, поэтому его выходные имена могут быть "DP1" и "DP2", а имя монитора - "Dell UP2414Q". 

(Обратите внимание, что даже если вы укажете имя выхода, который не охватывает весь монитор, i3 все равно будет использовать всю область содержащего монитора, а не только выходные данные).

Вы можете указать несколько выходов. Будет использоваться первый доступный.

Если вы используете именованные рабочие пространства, они должны быть процитированы:

**Примеры:**

```
workspace 1 output LVDS1
workspace 2 output primary
workspace 5 output VGA1 LVDS1
workspace "2: vim" output VGA1
```

### 4.20. Изменение цвета

Вы можете изменить все цвета, которые i3 использует для отрисовки оформления окон.

**Синтаксис:**

```
<класс_цвета> <граница> <фон> <текст> <индикатор> <граница_ребенка>
```

(пояснение переводчика: "ребенок" – это, следующий за родительским элементом, элемент)

Класс цвета может быть одним из этих:

* `client.focused` – клиент, который в настоящее время находится в фокусе;
* `client.focused_inactive` – клиент, чей контейнер имеет фокус, но сам не сфокусирован в данный момент;
* `client.unfocused` – клиент, чей контейнер не имеет фокуса;
* `client.urgent` – клиент, который отмечен как "срочный";
* `client.placeholder` – цвет фона и текста используется для отрисовки содержимого окна-платформы (при восстановлении раскладок). Рамка и индикатор игнорируются;
* `client.background` – цвет фона, который будет использоваться для раскраски фона клиентского окна, поверх которого будет отображаться клиент. Только те клиенты, которые не покрывают всю область этого окна, выставляют этот цвет. Обратите внимание, что этот цветовой класс принимает только один цвет.

Цвета приведены в шестнадцатеричном формате HTML (#rrggbb), см. следующий пример:

**Примеры (стандартные цвета):**

```
# класс					рамка	фон		текст	индик.	  рамка реб.
client.focused          #4c7899 #285577 #ffffff #2e9ef4   #285577
client.focused_inactive #333333 #5f676a #ffffff #484e50   #5f676a
client.unfocused        #333333 #222222 #888888 #292d2e   #222222
client.urgent           #2f343a #900000 #ffffff #900000   #900000
client.placeholder      #000000 #0c0c0c #ffffff #000000   #0c0c0c

client.background       #ffffff
```

Обратите внимание, что цвет вокруг окна ребенка – это "child_border", а цвет "border" – это только две тонкие линии вокруг заглавной панели.

Цвет индикатора используется для указания, где будет открыто новое окно. Для горизонтальных сплит-контейнеров будет окрашена в цвет индикатора правая граница, для вертикальных сплит-контейнеров – нижняя. Это относится только к одиночным окнам внутри сплит-контейнера, которые в противном случае неотличимы от одиночных окон за пределами сплит-контейнера.

### 4.21. Межпроцессное взаимодействие

i3 использует сокеты Unix, чтобы предоставить интерфейс IPC. Это позволяет сторонним программам получать информацию из i3, например, о текущем рабочем пространстве (для отображения панели рабочего пространства), а также управлять i3.

По умолчанию IPC сокет включен и будет создан в `$XDG_RUNTIME_DIR/i3/ipc-socket.%p`, если эта директория доступна. Запасным вариантом будет `/tmp/i3-%u.XXXXXX/ipc-socket.%p`. *%u* – это ваше имя пользователя Unix, *%p* – это PID для i3 и *XXXXXX* – это строка со случайными символами из переносного набора символов для наименования файлов (см. mkdtemp(3)).

Вы можете переопределить путь по умолчанию через переменную окружения I3SOCK или указав директиву ipc-socket. Однако это не рекомендуется, так как i3 по умолчанию делает правильные вещи. Если вы решите изменить ее, настоятельно рекомендуется установить ее в таком месте в вашем домашнем каталоге, чтобы ни один другой пользователь не мог создать этот каталог.

**Пример:**

```
ipc-socket ~/.i3/i3-ipc.sock
```

Далее вы можете использовать приложение *i3-msg*, чтобы выполнить любую команду из [списка команд]()(TODO: добавить ссылку).

### 4.22. Следование фокуса за мышью

По умолчанию фокус окна следует за вашей мышью и переключается, когда курсор пересекает границу окон. Однако, если в вашем случае это доставляет неудобства, то вы можете отключить это поведение и контролировать фокус только с помощью клавиатуры. Мышь по прежнему будет работать внутри активных окон (например, чтобы кликнуть на ссылку в браузере).

**Синтаксис**:

```
focus_follows_mouse yes|no
```

**Пример**:

```
focus_follows_mouse no
```

### 4.23. Искажение мыши

По умолчанию при переключении фокуса на окно на другом выходе (например, при фокусировке окна на рабочей области 3 на выходе VGA-1 из рабочей области 2 на LVDS-1), курсор мыши деформируется к центру этого окна.

С помощью опции `mouse_warping` вы можете контролировать когда курсор должен быть деформирован. `none` полностью отключает деформацию, в то время как `output` это стандартное поведение, описанное выше.

**Синтаксис**:

```
mouse_warping output|none
```

**Пример**:

```
mouse_warping none
```

### 4.24. Всплывающие окна в полноэкранном режиме

Когда вы находитесь в полноэкранном режиме некоторые приложения продолжают открывать всплывающие окна (возьмите Xpdf для примера). Это происходит потому, что эти приложения могут не знать о том, что они развернуты в полный экран (они не читают соответствующую подсказку). Есть 3 варианта того, что делать в данной ситуации:

1. Отображать всплывающее окно, если оно принадлежит только полноэкранному приложению. Это поведение по умолчанию и должно подходить для большинства пользователей. 
2. Просто игнорировать всплывающее окно. Это не помешает вам, пока вы в полноэкранном режиме, однако, некоторые приложения могут плохо реагировать на это (заблокироваться, когда вы покинете полноэкранный режим).
3. Выйти из полноэкранного режима.

**Синтаксис**:

```
popup_during_fullscreen smart|ignore|leave_fullscreen
```

**Пример**:

```
popup_during_fullscreen smart
```

### 4.25. Обертка фокуса

Представим, что есть контейнер с несколькими окнами или дочерними контейнерами. Если попробовать переместить фокус по краю контейнера, то фокус перейдет к противоположному окну, при условии, что других контейнеров в этом направлении нет. Это называется оборачиванием фокуса.

Если хотите, то можно отключить данное поведение установкой директивы `focus_wrapping` в значение `no`.

Обертка фокуса не произойдет, если есть другое окно или контейнер в указанном направлении. Фокус просто будет установлен на этом окне. Это поведение по умолчанию, поэтому вы "из коробки" можете перемещаться по всем своим окнам не используя *фокус родителя*.

Если вы хотите, чтобы фокус всегда был обернут и знаете как пользоваться *родительским фокусом* для переключения на разные контейнеры, вы можете установить `focus_wrapping` в значение `force`.

Чтобы ограничить фокус внутри текущего рабочего пространства установите `focus_wrapping` в значение `workspace`. Вам придется использовать *родительский фокус* до тех пор, пока вы не переключитесь на другую рабочую область с помощью команд фокусировки (команда `workspace` будет работать как и прежде).

**Синтаксис:**
```
focus_wrapping yes|no|force|workspace

# Старый синтаксис, эквивалентный "focus_wrapping force"
force_focus_wrapping yes
```

**Примеры:**
```
# Выключить обертывание фокуса
focus_wrapping no

# Принудительное обертывание
focus_wrapping force
```

### 4.26. Принудительное использование Xinerama

Некоторые видео-драйвера X11 (особенно бинарный драйвер nvidia) предоставляют поддержку только для Xinerama вместо RandR, об этом подробно написано [здесь](https://i3wm.org/docs/multi-monitor.html). В этом случае i3 необходимо явно указать использовать уступающий Xinerama API и, следовательно, перестать поддерживать переконфигурацию экранов "на лету" (они считываются только **единожды** при запуске).

Для пользователей, которые не могут изменять `~/.xsession` файл и, соответственно, добавить параметр `--force-xinerama`, конфигурация предоставляет отдельную опцию.

**Синтаксис:**
```
force_xinerama yes|no
```

**Пример:**

```
force_xinerama yes
```

Также обратите внимание, что ваши выводы имеют неочевидные имена при использовании Xinerama, вместо это они отсчитываются с нуля: xinerama-0, xinerama-1 и так далее.

### 4.28. Задержка сброса метки срочности при смене рабочего места

Если приложение на другом рабочем пространстве имеет метку о срочности, то переключение на это раб. пространство может привести к незамедлительному переключению фокуса на это приложение. Это также значит, что внешний вид окна сбросится до того, что описан в *client.focused*. Это может усложнить понимание того, в каком окне изначально произошло событие.

Чтобы избежать этого, вы можете указать задержку перед сбросом срочного состояния, используя директиву `force_display_urgency_hint`. Значение "0" отключает эту функцию.

Задержка по умолчанию – 500 мс.

**Синтаксис:**

```
force_display_urgency_hint <задержка> ms
```

**Пример:**

```
force_display_urgency_hint 500 ms
```

### 4.29. <span id="focus_on_window_activation">Фокус при активации окна</span>

Если окно активировано, например, через `google-chrome www.google.com`, оно может запросить фокус. Так как это может быть нежелательно для пользователя, это поведение можно настроить.

Обратите внимание, что это может и не повлиять на открываемые окна. Чтобы выключить фокусировку новых окон, см. раздел [Отключить фокусировку на новом окне](#no_focus).

**Синтаксис**:

```
focus_on_window_activation smart|urgent|focus|none
```

Описание режимов:

- **smart** – поведение по умолчанию. Если окно запрашивает фокус на активной раб. области, то оно получит его. В другом случае будет установлена метка срочности.

- **urgent** – окно в любом случае будет отмечена как срочное, но фокус не переключится.

- **focus** – окно всегда будет получать фокус и никогда не будет отмечено как срочное.

- **none** – окно не получит ни фокуса, ни метки срочности.

### 4.30. Отображение меток на оформлении окна

Если эта функция активирована, то метки (см. [vim_like_marks]()(TODO: добавить ссылку на раздел 6.14)) на окнах будут отображаться. Однако любая метка, начинающаяся с подчеркивания в ее названии ("_"), не будет показана, даже если эта опция активна.

По умолчанию опция имеет значение `yes`.

**Синтаксис**:

```
show_marks yes|no
```

**Пример**:

```
show_marks yes
```

### 4.31. Продолжение строки

Конфигурационные файлы поддерживают продолжение строки, т.е. когда вы заканчиваете строку символом обратного слеша ("\\"), синтаксический анализатор проигнорирует разрыв строки. Эта функция может быть использована для создания более читабельных конфигурационных файлов. Комментированные строки не продолжаются. 

**Примеры**:

```
bindsym Mod1+f \
fullscreen toggle

# запись выше прочитается так же, как и строка ниже
bindsym Mod1+f fullscreen toggle

# эта строка не будет продолжена \
bindsym Mod1+F fullscreen toggle
```

## 5. Настройка i3bar

Панель внизу вашего экрана отрисовывает процесс, который называется i3bar. Он является отдельным процессом и эта особенность имеет ряд преимуществ:

1. Модульность и модульный подход. Если вам вообще не нужна панель рабочего пространства, или вы предпочитаете другую (dzen2, xmobar, может быть даже gnome-panel?), вы можете просто удалить конфигурацию i3bar и вместо этого запустить вашу любимую панель.
2. Это соблюдает принцип философии UNIX: "Пусть каждая программа делает одну вещь, но делает ее хорошо". Пока i3 хорошо управляет вашими окнами, i3bar хорошо выполняет функцию отображения панели на каждом мониторе (если только вы не настроите его по-другому).
3. Такой подход разделяет базу исходного кода и сохраняет чистоту в ней. Если вы хотите понять i3, вам не нужно беспокоиться о деталях i3bar и наоборот.

При этом i3bar настраивается в том же файле конфигурации, что и i3. Это потому, что он тесно связан с i3 (в отличие от i3lock или i3status, которые полезны для людей, использующих другие оконные менеджеры). Поэтому нет смысла использовать другое место настройки, когда у нас уже есть хорошая конфигурационная инфраструктура.

Настройка панели рабочего пространства начинается с открытия *блока* панели. У вас может быть несколько таких блоков, чтобы использовать разные настройки на разных выводах (мониторах):

**Пример:**

```
bar {
	status_command i3status
}
```

### 5.1. Команда i3bar

По умолчанию i3 просто обойдет `i3bar`  и позволит вашей оболочке обрабатывать выполнение, она будет самостоятельно искать в `$PATH` корректную версию. Если у вас есть i3bar в другом месте или нет бинарного файла в `$PATH`, вы можете указать i3 напрямую что требуется запустить.

Указанная команда будет передана в `sh -c`, поэтому вы можете использовать шаблоны поиска (прим. переводчика: про шаблоны поиска см. [статью в Википедии](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0)), также нужно корректно цитировать пути и т. д.

**Синтаксис:**

```
i3bar_command <command>
```

**Пример:**

```
bar {
    i3bar_command /home/user/bin/i3bar
}
```

### 5.2. Команда строки статуса

i3bar может запускать программу и выводить каждую строку из ее вывода *stdout* в правой части панели. Это можно использовать для отображения системной информации, например, ваш текущий IP адрес, состояние батареи или время/дату.

Указанная команда будет передана в `sh -c`, поэтому вы можете использовать шаблоны поиска, также нужно корректно цитировать пути и т. д. Обратите внимание, что для обработки сигналов, в зависимости от вашей оболочки (известно, что это сказывается на пользователях dash(1)), вы должны использовать именно команду выполнения вашей оболочки, чтобы сигналы передавались не в нее, а в программу. 

**Синтаксис:**

```
status_command <command>
```

**Пример:**

```
bar {
    status_command i3status --config ~/.i3status.conf

    # Для пользователей dash(1), которые хотят использовать обработку сигналов:
    status_command exec ~/.bin/my_status_command
}
```

### 5.3. Режим отображения

Вы можете указать i3bar отображаться постоянно в одном из краев экрана – ***dock-режим*** или делать его видимым тогда, когда это требуется, по нажатию клавиши-модификатора – ***скрытый режим***. Также возможно насовсем скрыть его – ***невидимый режим***. Клавишу-модификатор можно настроить используя опцию `modifier`.

Режим можно изменить во время работы, используя команду `bar mode`. После перезагрузки режим вернется к тому, который задан в конфигурации.

Скрытый режим максимизирует пространство на экране, которое можно использовать для заполнения окнами. Также, i3bar отправляет сигналы *SIGSTOP* и *SIGCONT* в строку статуса, чтобы продлить срок жизни батареи.

Невидимый режим навсегда максимизирует свободное пространство на экране, потому что панель никогда не будет видна. Таким образом, вы можете настроить i3bar так, чтобы он не беспокоил вас, не выскакивал из-за подсказки срочности или из-за нажатия клавиши-модификатора.

Чтобы контролировать будет ли i3bar скрыт или показан в скрытом режиме существует опция hidden_state, которая не имеет никакого влияния в невидимом и dock-режиме. Она отвечает за текущий hidden_state панели: (1) панель работает как в обычном скрытом режиме, она скрыта и не скрывается только, если сработала пометка срочности или нажата клавиша-модификатор (hide state), или (2) отрисовывается поверх видимой в настоящее время рабочей области (show state).

Также как и режим, опция hidden_state может контролироваться с помощью i3, этого можно добиться, используя команду `bar hidden_state`.

По умолчанию работает dock-режим; в скрытом режиме клавиша по умолчанию это Mod4 (обычно это клавиша win). Значение по умолчанию для hidden_state – *hide*.

**Синтаксис:**

```
mode dock|hide|invisible
hidden_state hide|show
modifier <Modifier>|none
```

**Пример:**

```
bar {
    mode hide
    hidden_state hide
    modifier Mod1
}
```

Доступные модификаторы: Mod1-Mod5, Shift, Control (см. `xmodmap(1)`). Вы также можете использовать "none", если не хотите, чтобы какой-либо менял это поведение.

### 5.4. Команды кнопок мыши

Можно задать команду, которая будет выполняться при нажатии кнопки в i3bar для переопределения поведения по умолчанию. Это полезно, например, для отключения действия колеса прокрутки или запуска сценариев, реализующих пользовательское поведение этих кнопок.

Кнопки всегда именованы как `button<n>`, где от 1 до 5 стандартные кнопки, а числа выше могут означать специальные кнопки на устройствах, предлагающих большее количество кнопок:

* button1 – левая кнопка мыши;
* button2 – средняя кнопка мыши (колесико);
* button3 – правая кнопка мыши;
* button4 – прокрутка колесика вверх;
* button5 – прокрутка колесика вниз.

Обратите внимание, что старые команды `wheel_up_cmd` и `wheel_down_cmd` устарели и будут удалены в будущих релизах. Мы настоятельно рекомендуем использовать вместо этого `bindsym` с `button4` и `button5`.

**Синтаксис:**

```
bindsym [--release] button<n> <команда> 
```

**Пример:**

```
bar {
    # отключить нажатие на кнопки рабочей области
    bindsym button1 nop
    # сделать скриншот с помощью ПКМ на панели
    bindsym --release button3 exec --no-startup-id import /tmp/latest-screenshot.png
    # запустить пользовательский скрипт во время прокрутки вниз 
    bindsym button5 exec ~/.i3/scripts/custom_wheel_down
}
```

### 5.5. ID панели

Указание идентификатора панели для настроенного экземпляра панели. Если эта опция отсутствует, то ID устанавливается как *bar-x*, где x соответствует положению блока встраиваемых панелей в конфигурационном файле (bar-0, bar-1, ...).

**Синтаксис:**

```
id <id_панели>
```

**Пример:**

```
bar {
    id bar-1
}
```

### 5.6. Позиция

Эта опция отвечает за то, где i3bar будет отображаться.

Стандартное значение – внизу.

**Синтаксис:**

```
position top|bottom
```

**Пример:**

```
bar {
    position top
}
```

### 5.7. Вывод(ы)

Вы можете ограничить i3bar на один вывод (монитор) или более. По умолчанию обрабатываются все выводы. Ограничение выводов полезно при использовании разных опций для разных выводов с помощью нескольких блоков панели.

Чтобы заставить конкретный экземпляр i3bar обрабатывать несколько выходов, укажите выходную директиву несколько раз.

**Синтаксис:**

```
output primary|<вывод>
```

**Пример:**

```
# большой монитор: всё
bar {
    # Дисплей подключен через HDMI или DisplayPort
    output HDMI2
    output DP2
    status_command i3status
}

# монитор ноутбука: яркие цвета и i3status с меньшим количеством модулей.
bar {
    output LVDS1
    status_command i3status --config ~/.i3status-small.conf
    colors {
        background #000000
        statusline #ffffff
    }
}

# show bar on the primary monitor and on HDMI2
# показывать панель на основном мониторе и на HDMI2
bar {
    output primary
    output HDMI2
    status_command i3status
}
```

Обратите внимание, что, возможно, у вас еще не настроен первичный вывод. Для настройки запустите:

```
xrandr --output <вывод> --primary
```

### 5.8. Вывод трея

i3bar по умолчанию предоставляет место для системного трея, где такие программы, как NetworkManager, VLC, Pidgin и др. могут размещать свои маленькие иконки.

Вы можете настроить на каком выводе (мониторе) иконки будут отображаться или вовсе отключить этот функционал.

Можно использовать несколько директив `tray_output` в вашей конфигурации, чтобы задать список выводов, на которых вы хотите видеть трей. Первый доступный вывод в этом списке, определенный в порядке директив, будет использоваться для вывода в трей.

**Синтаксис:**

```
tray_output none|primary|<вывод>
```

**Пример:**

```
# отключить системный трей
bar {
    tray_output none
}

# показывать иконки трея на основном мониторе
bar {
    tray_output primary
}

# показывать иконки трея на большом мониторе
bar {
    tray_output HDMI2
}
```

Обратите внимание, что, возможно, у вас еще не настроен первичный вывод. Для настройки запустите:

```
xrandr --output <вывод> --primary
```

Обратите внимание, когда вы используете конфигурацию с несколькими блоками панели, нужно указать `tray_output primary` в каждом из них или явно указать `tray_output none` в панелях, которые не должны отображать трей. В противном случае различные экземпляры могут конкурировать друг с другом при попытке отображения значков в трее.

### 5.9. Отступ трея

Трей показан на правой стороне панели. По умолчанию для верхней, нижней и правой стороны области трея и между отдельными иконками используется отступ из 2 пикселей.

Синтаксис:

```
tray_padding <px> [px]
```

Пример:

```
# Отступы в соотвествии с законом Фиттса
tray_padding 0
```

(прим. переводчика: про закон Фиттса в проектировании интерфейсов и веб-дизайне можно почитать [здесь](https://askusers.ru/blog/pravila/zakon-fittsa-v-proektirovanii-interfeysov/))

### 5.10. Шрифт

Задать шрифт, который будет использоваться в панели можно способом, описанным ниже. См. [Шрифты](#fonts).

**Синтаксис:**

```
font <шрифт>
```

**Пример:**

```
bar {
    font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1
    font pango:DejaVu Sans Mono 10
}
```

### 5.11. Пользовательский символ разделителя

Определяет пользовательский символ, который будет использоваться для разделителя в отличие от вертикального разделителя толщиной в один пиксель.

**Синтаксис:**

```
separator_symbol <символ>
```

**Пример:**

```
bar {
    separator_symbol ":|:"
}
```

### 5.12. Кнопки рабочей области

Задает будут ли отображаться кнопки рабочего пространства или нет. Это полезно, если вы хотите отобразить только строку состояния, содержащую дополнительную информацию.

По умолчанию кнопки рабочих областей отображаются.

**Синтаксис:**

```
workspace_buttons yes|no
```

**Пример:**

```
bar {
    workspace_buttons no
}
```

### 5.13. Минимальная ширина для кнопок раб. области

По умолчанию ширина кнопки рабочей области задается шириной текста, который отображает имя раб. области. Если имя слишком короткое (скажем, одна буква), то кнопка может выглядеть слишком маленькой.

Эта опция задает минимальную ширину кнопки раб. области. Если имя раб. области слишком короткое и не покрывает кнопку полностью, будут добавлены отступы с обеих сторон и, в результате, текст будет центрирован.

Значение по умолчанию это ноль, что значит отсутствие дополнительных отступов.

Настройка также распространяется на индикатор режима привязки.

Обратите внимание, что указанные пиксели обозначают логические пиксели, которые могут преобразоваться в большее количество пикселей на HiDPI-дисплеях.

**Синтаксис:**

```
workspace_min_width <px> [px]
```

**Пример:**

```
bar {
    workspace_min_width 40
}
```

### 5.14. Удалить номер/имя раб. области

Указывает, должны ли номера рабочих областей отображаться в кнопках рабочей области. Это полезно, если вы хотите, чтобы именованная рабочая область оставалась на панели в соответствии с ее номером без отображения префикса номера.

Когда параметр `strip_workspace_numbers` установлен в `yes`, в любой рабочей области, имеющей имя по типу "\[n\]\[:\]\[NAME\]", будет отображаться только имя. Вы можете использовать это, например, для отображения римских цифр вместо арабских, называя рабочие пространства "1:I", "2:II", "3:III", "4:IV", ...

Когда параметр `strip_workspace_name` установлен в `yes`, в любой рабочей области, имеющей имя по типу "\[n\]\[:\]\[NAME\]", будет отображаться только порядковый номер.

По умолчанию отображается полное имя на кнопке. Помните, что двоеточие в имени рабочей области является необязательным, поэтому в `[n] [NAME]` также будет корректно удалено имя и номер рабочей области.

**Синтаксис:**

```
strip_workspace_numbers yes|no
strip_workspace_name yes|no
```

**Пример:**

```
bar {
    strip_workspace_numbers yes
}
```

### 5.15. Индикатор режима привязки

Указывает, должен ли отображаться индикатор текущего режима привязки. Это полезно, если вы хотите скрыть кнопки в рабочей области, но при этом видеть индикатор текущего режима привязки. Смотрите раздел [Режимы привязки](#binding_modes), чтобы узнать, что такое режимы и как их использовать.

По умолчанию индикатор режима отображается.

**Синтаксис:**

```
binding_mode_indicator yes|no
```

**Пример:**

```
bar {
    binding_mode_indicator no
}
```

### 5.16. Цвета

Как и в i3, цвета находятся в шестнадцатеричном формате HTML (#rrggbb). На данный момент можно настроить следующие цвета:

* `background` – фоновый цвет панели;
* `statusline` – цвет текста в строке статуса;
* `separator `– цвет символа разделителя;
* `focused_background` – фоновый цвет панели на сфокусированном мониторе. Если не задан, то будет взят из `background`;
* `focused_statusline` – цвет текста в строке статуса на сфокусированном мониторе. Если не задан, то будет взят из `statusline`;
* `focused_separator` – цвет символа разделителя на сфокусированном мониторе. Если не задан, то будет взят из `separator `;
* `focused_workspace` – рамка, фон и цвет текста для кнопки рабочей области, когда рабочая область имеет фокус;
* `active_workspace` – рамка, фон и цвет текста для кнопки рабочей области, когда рабочая область активна (видна) на каком-то выводе, но фокус на другом. Вы можете отличить это только от сфокусированного рабочего пространства, когда вы используете несколько мониторов;
* `inactive_workspace` – рамка, фон и цвет текста для кнопки рабочей области, когда рабочая область не имеет фокуса и не активна (не видна) ни на одном выводе. Так будет происходить в большинстве рабочих пространств;
* `urgent_workspace` – рамка, фон и цвет текста для кнопки рабочей области, когда рабочая область содержит окно с меткой срочности;
* `binding_mode` – рамка, фон и цвет текста для индикатора режима привязки. Если не задан, то цвета будут взяты из `urgent_workspace`.

**Синтаксис:**

```
colors {
    background <цвет>
    statusline <цвет>
    separator <цвет>

    <класс_цвета> <рамка> <фон> <текст>
}
```

**Пример:**

```
bar {
    colors {
        background #000000
        statusline #ffffff
        separator #666666

        focused_workspace  #4c7899 #285577 #ffffff
        active_workspace   #333333 #5f676a #ffffff
        inactive_workspace #333333 #222222 #888888
        urgent_workspace   #2f343a #900000 #ffffff
        binding_mode       #2f343a #900000 #ffffff
    }
}
```

### 5.17. Прозрачность

i3bar поддерживает прозрачность. Для этого нужно указать флаг `--transparency` в конфигурации:

**Синтаксис:**

```
bar {
    i3bar_command i3bar --transparency
}
```

В конфигурации i3bar вы можете использовать цвета в формате RGBA, т.е. последние две (шестнадцатеричные) цифры указывают на прозрачность. Например, `#00000000` будет полностью прозрачным, а `#000000FF` будет полностью непрозрачный чёрный (тоже самое, что `#000000`).

Обратите внимание, что в связи с тем, как работает спецификация трея, включение этого флага приведет к тому, что все иконки в трее будут иметь прозрачный фон.

## 6. Список команд

Команды это то, что вы привязываете к определенным горячим клавишам. Вы также можете отдавать команды во время выполнения без нажатия клавиши, используя IPC-интерфейс. Простой способ сделать это - использовать утилиту `i3-msg`.

**Пример:**

```
# запустите это в вашей оболочке, чтобы отключить рамки у текущего контейнера 
i3-msg border none
```

Команды могут быть привязаны с помощью символа `;` (точки с запятой). Таким образом, чтобы переместить окно в определенную рабочую область и сразу же переключиться на эту рабочую область, вы можете привязать клавишу следующим образом:

**Пример:**

```
bindsym $mod+x move container to workspace 3; workspace 3
```

Кроме того, вы можете изменить область действия команды - т.е. какие контейнеры должны быть затронуты этой командой. Для этого используются критерии. Они указываются перед любой командой в паре квадратных скобок и разделены пробелом.

При указании нескольких команд, отделите их символом `,` (запятой) вместо точки с запятой. Критерия действует только до следующей точки с запятой, поэтому, если вы используете точку с запятой для отделения команд, только первая из них будет выполнена для выбранных окон.

**Пример:**

```
# если вы хотите уничтожить все окна с классом Firefox, используйте:
bindsym $mod+x [class="Firefox"] kill

# тоже самое, но теперь не зависит от регистра
bindsym $mod+x [class="(?i)firefox"] kill

# уничтожить только диалог "О программе" в Firefox 
bindsym $mod+x [class="Firefox" window_role="About"] kill

# включить плавающий режим и переместить контейнер в раб. область 4 
for_window [class="^evil-app$"] floating enable, move container to workspace 4

# переместить все плавающие окна на скрэтчпад
bindsym $mod+x [floating] move scratchpad
```

Критерии, которые на данный момент есть:

* `class` - сравнивает класс окна (вторую часть WM_CLASS). Используйте особое значение `__focused__`, чтобы выделить все окна с нужным классом имеющие фокус.
* `instance` - сравнивает экземпляр окна (первую часть WM_CLASS). Используйте особое значение `__focused__`, чтобы выделить все окна с данным экземпляром имеющие фокус.
* `window_role` - сравнивает роль окна (WM_WINDOWS_ROLE). Используйте особое значение `__focused__`, чтобы выделить все окна с данной ролью имеющие фокус.
* `window_type` - сравнивает тип окна (\_NET_WM_WINDOW_TYPE). Возможные значения: `normal`, `dialog`, `utility`, `toolbar`, `splash`, `menu`, `dropdown_menu`, `popup_menu`, `tooltip`, `notification`.
* `id` - сравнивает ID окна X11, который вы можете получить, например, с помощью `xwininfo`.
* `title` - сравнивает заголовок окна X11 (\_NET_WM_NAME или WM_NAME как запасной вариант). Используйте особое значение `__focused__`, чтобы выделить все окна с таким же заголовком имеющие фокус.
* `urgent` - сравнивает состояние срочности окна. Может быть "latest" или "oldest". (Также доступны следующие псевдонимы: новый, последний, последний, первый.)
* `workspace` - сравнивает имя рабочей области, к которой принадлежит окно. Используйте специальное значение `__focused__` для сравнения всех окон в текущей фокусировке рабочей области.
* `con_mark` - сравнивает метки, установленные для этого контейнера, см. раздел [vim_like_marks](TODO: добавить ссылку). Сравнение производится, если какая-либо из меток контейнера совпадает с заданной отметкой.
* `con_id` - сравнивает внутренний ID контейнера, который можно получить через IPC-интерфейс. Удобен для написания сценариев. Использует специально значение `__focused__` для сравнения только со сфокусированным окном. 
* `floating` - совпадает только с плавающими окнами. Этот критерий не требует никакого значения. 
* `tiling` - совпадает только с тайлинговыми окнами. Этот критерий не требует никакого значения.

Критерии `class`, `instance`, `role`, `title`, `workspace` и `mark` на самом деле являются регулярными выражениями (PCRE). См. `pcresyntax(3)` или `perldoc perlre`, чтобы узнать как пользоваться ими.


